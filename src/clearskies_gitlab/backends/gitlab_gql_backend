from __future__ import annotations

import re
from collections.abc import Callable
from typing import Any

from clearskies import Model, column_types, functional
from clearskies.autodoc.schema import String as AutoDocString
from gql import Client, gql
from gql.transport.aiohttp import AIOHTTPTransport
from requests import Session

from clearskies_gitlab.models.backends import gitlab_auth


class GitlabGqlBackend(clearskies.backends.Backend):
    """Backend to gitlab using graphql."""

    base_url = "https://gitlab.com/api/graphql"
    access_token: str = ""
    _client: Client

    url = inject.ByName("gitlab_url", cache=True)
    auth = inject.ByName("gitlab_auth", cache=False)
    requests = inject.Requests()

    def __init__(self) -> None:
        """Create the api."""

    def _get_client(self) -> Client:
        if hasattr(self, "client") and self._client:
            return self._client
        transport = AIOHTTPTransport(url=self.url, headers=self._auth.headers())
        self._client = Client(transport=transport, fetch_schema_from_transport=True)
        return self._client

    def validate_gitlab_token(self) -> bool:
        """Validate if token is still use."""
        response = self._requests.get(
            "https://gitlab.com/api/v4/user/status",
            headers={"PRIVATE-TOKEN": self._access_token},
        )
        return response.status_code == 200

    def update(self, id: str, data: dict[str, Any], model: Model) -> dict[str, Any]:
        """Update the record with the given id with the information from the data dictionary."""
        raise NotImplementedError("Too lazy for update")

    def create(self, data: dict[str, Any], model: Model) -> dict[str, Any]:
        """Create a record with the information from the data dictionary."""
        raise NotImplementedError("Too lazy for create")

    def delete(self, id: str, model: Model) -> bool:
        """Delete the record with the given id."""
        raise NotImplementedError("Too lazy for delete")

    def count(self, configuration: dict[str, Any], model: Model) -> int:
        """Return the number of records which match the given query configuration."""
        raise NotImplementedError("Too lazy for count")  # noqa: TRY003

    def records(
        self, configuration: dict[str, Any], model: Model, next_page_data: dict[str, str] = {}
    ) -> list[dict[str, Any]]:
        """
        Return a list of records that match the given query configuration.

        next_page_data is used to return data to the caller.  Pass in an empty dictionary, and it will be populated
        with the data needed to return the next page of results.  If it is still an empty dictionary when returned,
        then there is no additional data.
        """
        variable_values = {}
        variable_placeholders = []
        query_attributes = []

        cursor = configuration["pagination"].get("cursor")
        if cursor:
            variable_values["cursor"] = configuration["pagination"]["cursor"]
            variable_placeholders.append("$cursor: String!")
            query_attributes.append("after: $cursor")
        elif model.root_list:
            query_attributes.append("after: null")
        limit = configuration["limit"] if configuration["limit"] else "100"

        model_columns = configuration["model_columns"]
        # when we search on parents we have to take a different approach, so we need to know about the belongs-to
        # relationships available in the model.
        parent_name = ""
        parent_id_value = ""
        for where in configuration["wheres"]:
            column_name = where["column"]
            if column_name in model_columns and isinstance(model_columns[column_name], column_types.BelongsTo):
                parent_belongs_to_column = model_columns[column_name]
                parent_model_class = parent_belongs_to_column.config("parent_models_class")
                parent_name = parent_model_class.table_name()
                parent_id_value = parent_model_class.gitlab_id_pattern.replace("[ID]", where["values"][0])
                continue

            if column_name != "id":
                raise ValueError("I currently only support searching on ids and parents")  # noqa: TRY003

            if model.root_list:
                variable_placeholders.append("$ids: [ID!]")
                query_attributes.append("ids: $ids")
                variable_values["ids"] = [model.gitlab_id_pattern.replace("[ID]", id) for id in where["values"]]
            else:
                id_name = functional.string.camel_case_to_words(model.table_name()).title().replace(" ", "") + "ID"
                variable_placeholders.append(f"$id: {id_name}!")
                query_attributes.append("id: $id")
                variable_values["id"] = model.gitlab_id_pattern.replace("[ID]", where["values"][0])

        if parent_name:
            parent_id_name_title_case = functional.string.camel_case_to_words(parent_name).title().replace(" ", "")
            variable_placeholders.append(f"$id: {parent_id_name_title_case}ID!")
            variable_values["id"] = parent_id_value

        query_addendum = "(" + ", ".join(variable_placeholders) + ")" if variable_placeholders else ""
        if model.root_list:
            query_attributes.extend([f"first: {limit}", "before: null"])

        object_addendum = "(" + ", ".join(query_attributes) + ")" if query_attributes else ""

        singular_name = model.table_name()
        plural_name = singular_name[:-1] + "ies" if singular_name[-1] == "y" else f"{singular_name}s"
        query_name = plural_name if model.root_list else singular_name
        selects = (
            " ".join(configuration.get("selects", []))
            if configuration.get("selects")
            else " ".join([column.name for column in model.columns().values() if self._allowed_select_column(column)])
        )

        if parent_name:
            query = f"""
            query select{query_name}{query_addendum} {{
            {parent_name}(id: $id) {{
                id
                {plural_name}{object_addendum} {{
                  nodes {{
                    {selects}
                  }}
                  pageInfo {{
                    endCursor
                    hasNextPage
                  }}
                }}
              }}
            }}
            """
        elif not model.root_list:
            query = f"""
            query select{query_name}{query_addendum} {{
              {query_name}{object_addendum} {{
                {selects}
              }}
            }}
            """
        else:
            query = f"""
            query select{query_name}{query_addendum} {{
              {query_name}{object_addendum} {{
                nodes {{
                  {selects}
                }}
                pageInfo {{
                  endCursor
                  hasNextPage
                }}
              }}
            }}
            """

        results = self._execute_gql(query, variable_values)
        if parent_name:
            records = results[parent_name][plural_name]["nodes"]
            pagination = results[parent_name][plural_name]["pageInfo"]
            if pagination["hasNextPage"]:
                next_page_data["cursor"] = pagination["endCursor"]
            return self._map_ids(records, model.gitlab_id_pattern)
        elif model.root_list:
            records = results[plural_name]["nodes"]
            pagination = results[plural_name]["pageInfo"]
            if pagination["hasNextPage"]:
                next_page_data["cursor"] = pagination["endCursor"]
            return self._map_ids(records, model.gitlab_id_pattern)
        else:
            return self._map_ids([results[singular_name]], model.gitlab_id_pattern)

    def _allowed_select_column(self, column: column_types.Column) -> bool:
        return not isinstance(column, column_types.BelongsTo | column_types.HasMany | column_types.ManyToMany)

    def _map_ids(self, records: list[dict[str, Any]], gitlab_id_pattern: str) -> list[dict[str, Any]]:
        if not gitlab_id_pattern:
            return records
        re_string = gitlab_id_pattern.replace("[ID]", r"(\d+)")
        id_search = re.compile(re_string)
        mapped_records = []
        for record in records:
            if "id" not in record:
                mapped_records.append(record)
                continue

            match = id_search.match(record["id"])
            if not match:
                raise ValueError(  # noqa: TRY003
                    f"I was unable to find the id for a record returned from Gitlab. The id is '{record['id']}' and I used a pattern of '{re_string}' but found no match"
                )
            mapped_records.append(
                {
                    **record,
                    "id": match[1],
                }
            )
        return mapped_records

    def _execute_gql(
        self, query: str, variable_values: dict[str, Any] | None = None, cursor: str = ""
    ) -> dict[str, Any]:
        prepared_query = gql(query)
        return self._get_client().execute(prepared_query, variable_values=variable_values)  # type: ignore[no-any-return]

    def validate_pagination_kwargs(self, kwargs: dict[str, Any]) -> str:
        """
        Check if the given dictionary is valid pagination data for the background.

        Returns a string with an error message, or an empty string if the data is valid
        """
        return ""

    def allowed_pagination_keys(self) -> list[str]:
        """
        Return the list of allowed keys in the pagination kwargs for the backend.

        It must always return keys in snake_case so that the auto casing system can
        adjust on the front-end for consistency.
        """
        return []

    def documentation_pagination_next_page_response(self, case_mapping: Callable[..., str]) -> list[Any]:
        """
        Return a list of autodoc schema object.

        Describes the contents of the `next_page` dictionary in the pagination section of the response.
        """
        return [AutoDocString(case_mapping("cursor"))]

    def documentation_pagination_parameters(self, case_mapping: Callable[..., str]) -> list[tuple[Any, str]]:
        """
        Return a list of autodoc schema objects describing the allowed input keys to set pagination.

        It should return a list of tuples, with each tuple corresponding to an input key.  The first element in the
        tuple should be the schema, and the second should be the description.
        """
        return [
            (
                AutoDocString(case_mapping("cursor"), example="eyJpZCI6IHsiUyI6ICIzODM0MyJ9fQ=="),
                "A token to fetch the next page of results",
            )
        ]

    def documentation_pagination_next_page_example(self, case_mapping: Callable[..., str]) -> dict[str, Any]:
        """Return an example of what the next_page data in the pagination response should look like."""
        return {case_mapping("cursor"): "eyJpZCI6IHsiUyI6ICIzODM0MyJ9fQ=="}
